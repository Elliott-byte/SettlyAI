name: BE_CD
on:
  push:
    branches: [ main ]
    paths: [ 'backend/**' ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-southeast-2

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 1) 查找目标 EC2（按 Name 标签，且需处于 running）
      - name: Find EC2 instance
        id: ec2
        run: |
          set -euo pipefail
          echo "Looking for EC2 tagged Name=${{ secrets.AWS_EC2_NAME }}..."
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ secrets.AWS_EC2_NAME }}" "Name=instance-state-name,Values=running" \
            --region $AWS_REGION \
            --query "Reservations[].Instances[0].InstanceId" \
            --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "❌ No running instance found by that Name tag."
            exit 1
          fi
          echo "Found EC2 instance ID: $INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

      # 2) 等待实例在 SSM 中注册为受管
      - name: Wait for SSM registration
        run: |
          set -euo pipefail
          echo "Waiting for EC2 to register with SSM..."
          for i in {1..10}; do
            MATCHED=$(aws ssm describe-instance-information \
              --region $AWS_REGION \
              --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" \
              --output text)
            if [ -n "$MATCHED" ]; then
              echo "✅ EC2 instance registered with SSM!"
              exit 0
            fi
            echo "⏳ Not yet registered... retry in 5 seconds"
            sleep 5
          done
          echo "❌ EC2 instance did not register with SSM in time."
          exit 1

      # 3) 生成将要在 EC2 执行的脚本（使用 ECR Credential Helper，无需 docker login）
      - name: Build remote deploy script (ECR helper, no aws cli login)
        id: build-script
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          # 写入脚本：用带引号 heredoc，避免本地变量展开
          cat > /tmp/deploy-backend.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          export DEBIAN_FRONTEND=noninteractive

          echo "=== Detect/Install Docker ==="
          if ! command -v docker >/dev/null 2>&1; then
            if [ -f /etc/debian_version ]; then
              apt-get update -y
              apt-get install -y docker.io curl tar
            elif [ -f /etc/system-release ] && grep -qi "Amazon Linux 2" /etc/system-release; then
              amazon-linux-extras install docker -y
              yum install -y curl tar || true
            elif [ -f /etc/amazon-linux-release ] || [ -f /etc/redhat-release ]; then
              (yum install -y docker || dnf install -y docker)
              (yum install -y curl tar || dnf install -y curl tar) || true
            else
              echo "Unsupported Linux distro"; exit 1
            fi
          fi
          systemctl enable --now docker || service docker start || true

          echo "=== Install & configure ECR credential helper ==="
          ECR_REGISTRY="__ECR_REGISTRY__"
          AWS_REGION="__AWS_REGION__"
          ECR_HOST="__ECR_HOST__"

          if ! command -v docker-credential-ecr-login >/dev/null 2>&1; then
            VER="0.7.1"
            ARCH="linux-amd64"
            TMPD="$(mktemp -d)"
            curl -fsSL -o "$TMPD/docker-credential-ecr-login.tar.gz" \
              "https://github.com/awslabs/amazon-ecr-credential-helper/releases/download/v${VER}/docker-credential-ecr-login-${ARCH}-v${VER}.tar.gz"
            tar -xzf "$TMPD/docker-credential-ecr-login.tar.gz" -C "$TMPD"
            install -m 0755 "$TMPD/docker-credential-ecr-login" /usr/local/bin/docker-credential-ecr-login
            rm -rf "$TMPD"
          fi

          mkdir -p /root/.docker
          cat >/root/.docker/config.json <<JSON
          {
            "credHelpers": {
              "${ECR_HOST}": "ecr-login"
            }
          }
          JSON
          
          echo "=== Pull & Run Container (no docker login needed) ==="
          IMAGE="${ECR_REGISTRY}:latest"
          echo "Pulling $IMAGE ..."
          docker pull "$IMAGE"
          
          docker rm -f backend || true
          docker run -d --name backend --restart unless-stopped -p 5100:5100 \
            -e ASPNETCORE_ENVIRONMENT=Production "$IMAGE"
          
          echo "=== Post-Checks ==="
          docker ps
          ss -tulnp | grep :5100 || true
          docker logs --tail 100 backend || true
          EOF

          # 用实际值替换占位符（仍在 Runner 本地）
          ECR_HOST="$(echo "$ECR_REGISTRY" | awk -F/ '{print $1}')"
          sed -i \
            -e "s|__ECR_REGISTRY__|$ECR_REGISTRY|g" \
            -e "s|__AWS_REGION__|$AWS_REGION|g" \
            -e "s|__ECR_HOST__|$ECR_HOST|g" \
            /tmp/deploy-backend.sh

          chmod +x /tmp/deploy-backend.sh
          echo "script_path=/tmp/deploy-backend.sh" >> "$GITHUB_OUTPUT"

      # 4) 把脚本 Base64 编码，生成 SSM parameters（避免引号/换行问题）
      - name: Build SSM parameters JSON (base64 payload)
        id: build-params
        run: |
          set -euo pipefail
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq coreutils >/dev/null
          SCRIPT_B64=$(base64 -w0 /tmp/deploy-backend.sh 2>/dev/null || base64 /tmp/deploy-backend.sh | tr -d '\n')
          REMOTE_CMD="bash -lc 'echo ${SCRIPT_B64} | base64 -d >/tmp/deploy.sh && chmod +x /tmp/deploy.sh && /bin/bash /tmp/deploy.sh'"
          jq -n --arg c "$REMOTE_CMD" '{commands: [$c]}' > /tmp/ssm-params.json
          echo "params_path=/tmp/ssm-params.json" >> "$GITHUB_OUTPUT"

      # 5) 发送 SSM 命令
      - name: Send SSM command
        id: send
        run: |
          set -euo pipefail
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --region "$AWS_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --comment "Install Docker (if needed) + ECR helper + deploy backend" \
            --parameters file://${{ steps.build-params.outputs.params_path }} \
            --query "Command.CommandId" --output text)
          echo "SSM CommandId: $CMD_ID"
          echo "cmd_id=$CMD_ID" >> "$GITHUB_OUTPUT"

      # 6) 轮询并打印执行结果（只需 GetCommandInvocation）
      - name: Wait & fetch output
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.send.outputs.cmd_id }}"
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "$AWS_REGION" \
              --query "Status" --output text || true)
            echo "Invocation status: $STATUS"
            case "$STATUS" in
              Success|Cancelled|TimedOut|Failed) break ;;
              *) sleep 5 ;;
            esac
          done

          echo "===== STDOUT ====="
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "$AWS_REGION" \
            --query "StandardOutputContent" --output text || true

          echo "===== STDERR ====="
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "$AWS_REGION" \
            --query "StandardErrorContent" --output text || true

          if [ "$STATUS" != "Success" ]; then
            echo "SSM command finished with status: $STATUS"
            exit 1
          fi